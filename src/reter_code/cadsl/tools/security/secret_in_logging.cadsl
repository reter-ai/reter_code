# secret_in_logging - Find functions in logging/redaction code that handle secrets
#
# OpenClaw handles API keys, OAuth tokens, and credentials for many providers.
# The logging and redaction layer must sanitize all secrets before they reach
# log output. Complex redaction functions may have incomplete coverage, edge
# cases, or regex gaps that leak sensitive values into logs, debug output,
# or error messages.
#
# CWE-532: Insertion of Sensitive Information into Log File

detector secret_in_logging(category="security", severity="medium") {
    """Find functions in logging/redaction code that handle secrets - complexity means potential for incomplete redaction."""

    param min_lines: int = 5;
    param limit: int = 50;

    reql {
        SELECT ?m ?name ?file ?line ?line_count
        WHERE {
            { ?m type method } UNION { ?m type function }
            ?m has-name ?name .
            ?m is-in-file ?file .
            ?m is-at-line ?line .
            ?m has-line-count ?line_count .
            FILTER (REGEX(?name, "redact|mask|sanitize|summarize.*[Tt]oken.*[Cc]onfig|mask.*[Tt]oken"))
            FILTER (REGEX(?file, "log|redact|sanitiz"))
            FILTER (?line_count >= {min_lines})
            FILTER (!REGEX(?file, "test|spec|mock|node_modules|vendor"))
        }
        ORDER BY DESC(?line_count)
        LIMIT {limit}
    }
    | select { name, file, line, line_count }
    | map {
        ...row,
        issue: "secret_in_logging",
        message: "Secret-handling logging function '{name}' ({line_count} lines) in {file}:{line}",
        suggestion: "Review for: incomplete redaction patterns, regex gaps for new token formats, secrets in error messages or stack traces"
    }
    | emit { findings }
}

# Broader variant: also catch secret-related functions outside logging directories
detector secret_in_logging_broad(category="security", severity="medium") {
    """Find any function that handles token/secret display or summarization."""

    param min_lines: int = 5;
    param limit: int = 50;

    reql {
        SELECT ?m ?name ?file ?line ?line_count
        WHERE {
            { ?m type method } UNION { ?m type function }
            ?m has-name ?name .
            ?m is-in-file ?file .
            ?m is-at-line ?line .
            ?m has-line-count ?line_count .
            FILTER (REGEX(?name, "redact|mask[A-Z]|sanitize.*[Ss]ecret|summarize.*[Tt]oken"))
            FILTER (?line_count >= {min_lines})
            FILTER (!REGEX(?file, "test|spec|mock|node_modules|vendor"))
        }
        ORDER BY DESC(?line_count)
        LIMIT {limit}
    }
    | select { name, file, line, line_count }
    | map {
        ...row,
        issue: "secret_in_logging_broad",
        message: "Secret-handling function '{name}' ({line_count} lines) in {file}:{line}",
        suggestion: "Review for: incomplete redaction of new credential formats, partial masking that reveals structure"
    }
    | emit { findings }
}
