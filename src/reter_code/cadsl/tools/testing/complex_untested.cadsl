# complex_untested - Find complex code without tests
#
# Identifies long methods/functions that have no test coverage.
# Enhanced with RAG to find similar TESTED code as examples.

detector complex_untested(category="test_coverage", severity="high") {
    """Find complex code without test coverage, with similar tested code as examples."""

    param min_lines: int = 30;
    param limit: int = 50;
    param show_examples: bool = true;

    reql {
        SELECT ?e ?name ?class_name ?file ?line ?line_count
        WHERE {
            { ?e type method } UNION { ?e type function }
            ?e has-name ?name .
            ?e is-in-file ?file .
            ?e is-at-line ?line .
            ?e has-line-count ?line_count .
            OPTIONAL { ?e is-defined-in ?c . ?c has-name ?class_name }
            FILTER ( ?line_count >= {min_lines} )
            FILTER ( !REGEX(?file, "test_|_tests?\\.|/tests?/") )
            FILTER NOT EXISTS {
                ?test calls ?e .
                ?test is-in-file ?test_file .
                FILTER ( REGEX(?test_file, "test_|_tests?\\.|/tests?/") )
            }
        }
        ORDER BY DESC(?line_count)
        LIMIT {limit}
    }
    | select { name, class_name, file, line, line_count }
    | rag_enrich {
        query: "test {name} {class_name}",
        top_k: 3,
        threshold: 0.5,
        mode: all
    }
    | map {
        name: name,
        class_name: class_name ?? "",
        file: file,
        line: line,
        line_count: line_count,
        issue: "complex_untested",
        message: "'{name}' ({line_count} lines) has no tests",
        suggestion: "High-risk: add comprehensive tests for complex logic",
        example_count: len(rag_matches),
        similar_tested_code: rag_matches
    }
    | emit { findings }
}

# Simpler version without RAG enrichment for faster execution
detector complex_untested_fast(category="test_coverage", severity="high") {
    """Find complex code without test coverage (no examples)."""

    param min_lines: int = 30;
    param limit: int = 100;

    reql {
        SELECT ?e ?name ?class_name ?file ?line ?line_count
        WHERE {
            { ?e type method } UNION { ?e type function }
            ?e has-name ?name .
            ?e is-in-file ?file .
            ?e is-at-line ?line .
            ?e has-line-count ?line_count .
            OPTIONAL { ?e is-defined-in ?c . ?c has-name ?class_name }
            FILTER ( ?line_count >= {min_lines} )
            FILTER ( !REGEX(?file, "test_|_tests?\\.|/tests?/") )
            FILTER NOT EXISTS {
                ?test calls ?e .
                ?test is-in-file ?test_file .
                FILTER ( REGEX(?test_file, "test_|_tests?\\.|/tests?/") )
            }
        }
        ORDER BY DESC(?line_count)
        LIMIT {limit}
    }
    | select { name, class_name, file, line, line_count }
    | compute {
        entity_type: class_name ? "method" : "function"
    }
    | map {
        ...row,
        issue: "complex_untested",
        message: "Long {entity_type} '{name}' ({line_count} lines) has no tests",
        suggestion: "High-risk: add comprehensive tests for complex logic"
    }
    | emit { findings }
}
