# test_suggestions - Find methods that need tests with similar tested code as examples
#
# Enhanced with RAG to find similar tested methods as examples.
# This helps developers understand patterns they can follow when writing tests.

detector test_suggestions(category="test_coverage", severity="medium") {
    """Find public methods without tests, with similar tested code as examples."""

    param limit: int = 50;
    param show_examples: bool = true;

    # Find public methods in non-test files that have no test calling them
    reql {
        SELECT ?m ?name ?class_name ?file ?line
        WHERE {
            ?m type method .
            ?m has-name ?name .
            ?m is-defined-in ?c . ?c has-name ?class_name .
            ?m is-in-file ?file .
            ?m is-at-line ?line .
            FILTER (!STRSTARTS(?name, "_"))
            FILTER (!REGEX(?file, "test_|_tests?\\.|/tests?/"))
            FILTER NOT EXISTS {
                ?test calls ?m .
                ?test is-in-file ?test_file .
                FILTER (REGEX(?test_file, "test_|_tests?\\.|/tests?/"))
            }
        }
        ORDER BY ?file ?line
        LIMIT {limit}
    }
    | select { name, class_name, file, line }
    | rag_enrich {
        query: "test {name} {class_name}",
        top_k: 3,
        threshold: 0.5,
        mode: all
    }
    | map {
        name: name,
        class_name: class_name ?? "",
        file: file,
        line: line,
        issue: "needs_test",
        message: "'{class_name}.{name}' has no test coverage",
        suggestion: "Add unit tests for this method",
        example_count: len(rag_matches),
        similar_tested_code: rag_matches
    }
    | emit { findings }
}

# Simpler version without RAG enrichment for faster execution
detector test_suggestions_fast(category="test_coverage", severity="medium") {
    """Find public methods without tests (no examples)."""

    param limit: int = 100;

    reql {
        SELECT ?m ?name ?class_name ?file ?line
        WHERE {
            ?m type method .
            ?m has-name ?name .
            ?m is-defined-in ?c . ?c has-name ?class_name .
            ?m is-in-file ?file .
            ?m is-at-line ?line .
            FILTER (!STRSTARTS(?name, "_"))
            FILTER (!REGEX(?file, "test_|_tests?\\.|/tests?/"))
            FILTER NOT EXISTS {
                ?test calls ?m .
                ?test is-in-file ?test_file .
                FILTER (REGEX(?test_file, "test_|_tests?\\.|/tests?/"))
            }
        }
        ORDER BY ?file ?line
        LIMIT {limit}
    }
    | select { name, class_name, file, line }
    | map {
        name: name,
        class_name: class_name ?? "",
        file: file,
        line: line,
        issue: "needs_test",
        message: "'{class_name}.{name}' has no test coverage",
        suggestion: "Add unit tests for this method"
    }
    | emit { findings }
}
