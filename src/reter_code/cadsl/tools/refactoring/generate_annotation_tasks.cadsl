# Generate annotation tasks for classes without layer annotations
# Creates tasks in RETER session for each unannotated class
# Each task requires manual analysis to determine the correct layer

query generate_annotation_tasks(
    category = "annotation",
    capabilities = ["task_creation", "code_analysis"]
) {
    """
    Generate tasks to add @reter: layer annotations to classes.

    Finds all classes that don't have layer annotations and creates
    tasks for manual layer determination and annotation.

    Parameters:
        dry_run: If true, returns task data without creating tasks (default: true)
        limit: Maximum number of tasks to generate (default: 100)
    """

    param dry_run: bool = true;
    param limit: int = 100;

    reql {
        SELECT ?class ?name ?file ?line WHERE {
            ?class type class .
            ?class has-name ?name .
            ?class is-in-file ?file .
            ?class is-at-line ?line .
            FILTER NOT EXISTS { ?class type user:PresentationLayer }
            FILTER NOT EXISTS { ?class type user:ServiceLayer }
            FILTER NOT EXISTS { ?class type user:DSLLayer }
            FILTER NOT EXISTS { ?class type user:InfrastructureLayer }
            FILTER NOT EXISTS { ?class type user:CoreLayer }
            FILTER NOT EXISTS { ?class type user:TestLayer }
            FILTER NOT EXISTS { ?class type user:UtilityLayer }
            FILTER (!CONTAINS(?file, "test"))
            FILTER (!CONTAINS(?file, "tests"))
            FILTER (!CONTAINS(?file, "_test.py"))
            FILTER (!CONTAINS(?file, "test_"))
        }
        ORDER BY ?file ?line
    }
    | limit { {limit} }
    | map {
        class_name: name,
        file: file,
        line: line
    }
    | create_task {
        name: "Determine layer and add @reter annotation to {class_name}",
        category: "annotation",
        priority: medium,
        description: "Analyze class and add appropriate layer annotation.\n\nClass: {class_name}\nFile: {file}:{line}\n\nSteps:\n1. Read the class implementation\n2. Analyze responsibilities and dependencies\n3. Determine layer: PresentationLayer, ServiceLayer, DSLLayer, InfrastructureLayer, CoreLayer, TestLayer, UtilityLayer\n4. Identify functional component (e.g., Parser, Repository, Handler, Manager)\n5. Add @reter: <Layer>(self) and @reter: <FunctionalComponent>(self)\n\nLanguage syntax:\n- Python: in docstring\n- JS/TS: /** */ JSDoc\n- C#: /// XML doc\n- C++: /** */ or //\n\nNote: 'self' is auto-resolved to the class name.",
        affects: file,
        dry_run: {dry_run}
    }
    | emit { tasks }
}
