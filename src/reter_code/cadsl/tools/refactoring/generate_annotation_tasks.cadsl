// Generate annotation tasks for classes without layer annotations
// Creates tasks in RETER session for each unannotated class

query generate_annotation_tasks(
    category = "annotation",
    capabilities = ["task_creation", "code_analysis"]
) {
    """
    Generate tasks to add @reter: layer annotations to classes.

    Finds all classes that don't have layer annotations and creates
    tasks to add appropriate annotations based on file location and naming patterns.

    Parameters:
        dry_run: If true, returns task data without creating tasks (default: false)
        limit: Maximum number of tasks to generate (default: 100)
    """

    param dry_run: bool = false;
    param limit: int = 100;

    reql {
        SELECT ?class ?file ?line WHERE {
            ?class type oo:Class .
            ?class inFile ?file .
            ?class atLine ?line .
            FILTER NOT EXISTS { ?class type user:PresentationLayer }
            FILTER NOT EXISTS { ?class type user:ServiceLayer }
            FILTER NOT EXISTS { ?class type user:DSLLayer }
            FILTER NOT EXISTS { ?class type user:InfrastructureLayer }
            FILTER NOT EXISTS { ?class type user:CoreLayer }
            FILTER NOT EXISTS { ?class type user:TestLayer }
            FILTER NOT EXISTS { ?class type user:UtilityLayer }
        }
        ORDER BY ?file ?line
    }
    | limit { {limit} }
    | python {
        # Convert pyarrow to list of dicts if needed
        if hasattr(rows, 'to_pylist'):
            rows = rows.to_pylist()
        elif hasattr(rows, 'to_pydict'):
            d = rows.to_pydict()
            rows = [dict(zip(d.keys(), vals)) for vals in zip(*d.values())]

        # Determine layer based on file path and class name patterns
        output = []
        for row in rows:
            file = str(row.get('?file', '') or row.get('file', ''))
            cls = str(row.get('?class', '') or row.get('class', ''))
            # Extract just the class name from fully qualified name
            if '.' in cls:
                cls = cls.split('.')[-1]

            # Determine layer based on file path and class name
            if 'test' in file.lower():
                layer = 'TestLayer'
            elif 'services' in file or 'tools' in file:
                layer = 'ServiceLayer'
            elif 'cadsl' in file or 'dsl' in file:
                layer = 'DSLLayer'
            elif any(p in cls for p in ['Service', 'Manager', 'Handler']):
                layer = 'ServiceLayer'
            elif any(p in cls for p in ['Parser', 'Compiler', 'Transformer']):
                layer = 'DSLLayer'
            elif any(p in cls for p in ['Wrapper', 'Client', 'Store', 'Repository']):
                layer = 'InfrastructureLayer'
            elif any(p in cls for p in ['Step', 'Result']):
                layer = 'CoreLayer'
            else:
                layer = 'CoreLayer'

            row['suggested_layer'] = layer
            row['class_name'] = cls
            row['file'] = file
            row['line'] = row.get('?line', '') or row.get('line', '')
            output.append(row)

        result = output
    }
    | create_task {
        name: "Add @reter: {suggested_layer}(self) to {class_name}",
        category: "annotation",
        priority: low,
        description: "Add semantic layer annotation.\n\nFile: {file}:{line}\nAdd to docstring: @reter: {suggested_layer}(self)",
        affects: file,
        dry_run: {dry_run}
    }
    | emit { tasks }
}
