// REQL (RETE Query Language) Grammar for Lark
//
// A SPARQL-inspired query language for Description Logic and RETE networks.
// Converted from ReqlParser.g4 and ReqlLexer.g4
//
// Features:
// - SELECT, ASK, DESCRIBE queries
// - WHERE clause with triple patterns
// - FILTER expressions (comparison, boolean logic, functions)
// - UNION, OPTIONAL, MINUS patterns
// - GROUP BY, HAVING, ORDER BY, LIMIT, OFFSET
// - Aggregates: COUNT, SUM, AVG, MIN, MAX

// ========================================
// MAIN QUERY STRUCTURE
// ========================================

start: query

query: select_query
     | ask_query
     | describe_query

select_query: SELECT (DISTINCT | REDUCED)? (select_term+ | STAR) where_clause? solution_modifier

ask_query: ASK where_clause solution_modifier

describe_query: DESCRIBE (describe_target+ | STAR) where_clause?

describe_target: var
               | id

select_term: "(" select_query ")" AS var          // Scalar subquery
           | "(" aggregate AS var ")"             // SPARQL standard: (COUNT(?x) AS ?count)
           | aggregate AS var                      // Non-parenthesized
           | aggregate                             // Bare aggregate
           | var                                   // Simple variable

aggregate: COUNT "(" (DISTINCT var | STAR | var) ")"
         | SUM "(" DISTINCT? var ")"
         | AVG "(" DISTINCT? var ")"
         | MIN "(" DISTINCT? var ")"
         | MAX "(" DISTINCT? var ")"

// ========================================
// WHERE CLAUSE
// ========================================

where_clause: WHERE? group_graph_pattern

group_graph_pattern: "{" triples_block? ((graph_pattern_not_triples | filter_) "."? triples_block?)* "}"

triples_block: triples_same_subject ("." triples_block?)?

graph_pattern_not_triples: optional_graph_pattern
                         | group_or_union_graph_pattern
                         | minus_graph_pattern

optional_graph_pattern: OPTIONAL group_graph_pattern

group_or_union_graph_pattern: group_graph_pattern (UNION group_graph_pattern)*

minus_graph_pattern: MINUS group_graph_pattern

// ========================================
// TRIPLE PATTERNS
// ========================================

triples_same_subject: var_or_term property_list_not_empty
                    | triples_node property_list

property_list_not_empty: verb object_list (";" (verb object_list)?)*

property_list: property_list_not_empty?

object_list: object ("," object)*

object: graph_node

verb: var_or_identifier
    | A

// ========================================
// FILTER EXPRESSIONS
// ========================================

filter_: FILTER constraint

constraint: bracketted_expression
          | built_in_call

bracketted_expression: "(" expression ")"

expression: conditional_or_expression

conditional_or_expression: conditional_and_expression ("||" conditional_and_expression)*

conditional_and_expression: value_logical ("&&" value_logical)*

value_logical: relational_expression

relational_expression: additive_expression ((EQUAL | NOT_EQUAL | LESS | GREATER | LESS_OR_EQUAL | GREATER_OR_EQUAL) additive_expression)?

numeric_expression: additive_expression

additive_expression: multiplicative_expression ((PLUS | MINUS_OP) multiplicative_expression)*

multiplicative_expression: unary_expression ((STAR | SLASH) unary_expression)*

unary_expression: (EXCLAMATION | PLUS | MINUS_OP)? primary_expression

primary_expression: bracketted_expression
                  | built_in_call
                  | aggregate
                  | numeric_literal
                  | boolean_literal
                  | string
                  | var
                  | id

// ========================================
// BUILT-IN FUNCTIONS
// ========================================

built_in_call: STR "(" expression ")"
             | BOUND "(" var ")"
             | REGEX "(" expression "," expression ("," expression)? ")"
             | CONTAINS "(" expression "," expression ")"
             | STRSTARTS "(" expression "," expression ")"
             | STRENDS "(" expression "," expression ")"
             | EXISTS group_graph_pattern
             | not_exists_func

not_exists_func: NOT EXISTS group_graph_pattern

// ========================================
// SOLUTION MODIFIERS
// ========================================

solution_modifier: group_clause? having_clause? order_clause? limit_offset_clauses?

group_clause: GROUP BY var+

having_clause: HAVING constraint+

order_clause: ORDER BY order_condition+

order_condition: (ASC | DESC) bracketted_expression
               | constraint
               | var

limit_offset_clauses: limit_clause offset_clause?
                    | offset_clause limit_clause?

limit_clause: LIMIT NAT

offset_clause: OFFSET NAT

// ========================================
// VALUES CLAUSE (for future support)
// ========================================

values_clause: VALUES data_block

data_block: inline_data_one_var
          | inline_data_full

inline_data_one_var: var "{" data_block_value* "}"

inline_data_full: "(" var* ")" "{" ("(" data_block_value* ")")* "}"

data_block_value: id
                | numeric_literal
                | boolean_literal
                | var

// ========================================
// TERMS AND NODES
// ========================================

triples_node: collection
            | blank_node_property_list

blank_node_property_list: "[" property_list_not_empty "]"

collection: "(" graph_node+ ")"

graph_node: var_or_term
          | triples_node

var_or_term: var
           | graph_term

var_or_identifier: var
                 | id

var: VAR

graph_term: id
          | numeric_literal
          | boolean_literal
          | string

id: ID

// ========================================
// LITERALS
// ========================================

numeric_literal: NAT
               | NUM
               | DBL

boolean_literal: TRUE
               | FALSE

string: STRING_LITERAL

// ========================================
// TERMINALS - Keywords (case-insensitive)
// ========================================

A: "a"i

AS: "as"i
ASC: "asc"i
ASK: "ask"i
AVG: "avg"i
BOUND: "bound"i
BY: "by"i
CONTAINS: "contains"i
COUNT: "count"i
DESC: "desc"i
DESCRIBE: "describe"i
DISTINCT: "distinct"i
EXISTS: "exists"i
FILTER: "filter"i
FROM: "from"i
GROUP: "group"i
HAVING: "having"i
LIMIT: "limit"i
MAX: "max"i
MIN: "min"i
MINUS: "minus"i
NOT: "not"i
OFFSET: "offset"i
OPTIONAL: "optional"i
ORDER: "order"i
REDUCED: "reduced"i
REGEX: "regex"i
SELECT: "select"i
STRENDS: "strends"i
STRSTARTS: "strstarts"i
STR: "str"i
SUM: "sum"i
UNION: "union"i
VALUES: "values"i
WHERE: "where"i
TRUE: "true"i
FALSE: "false"i

// ========================================
// TERMINALS - Operators
// ========================================

EQUAL: "="
NOT_EQUAL: "!="
LESS: "<"
GREATER: ">"
LESS_OR_EQUAL: "<="
GREATER_OR_EQUAL: ">="
PLUS: "+"
MINUS_OP: "-"
SLASH: "/"
STAR: "*"
EXCLAMATION: "!"

// ========================================
// TERMINALS - Literals and Identifiers
// ========================================

// Variables: ?x or $x
VAR: /[\?$][a-zA-Z_][a-zA-Z0-9_]*/

// Natural numbers (unsigned integers)
NAT: /[0-9]+/

// Signed integers
NUM: /[+-]?[0-9]+/

// Floating point numbers
DBL: /[+-]?[0-9]*\.[0-9]+([eE][+-]?[0-9]+)?/

// String literals (single or double quoted)
STRING_LITERAL: /'(?:''|[^'])*'/ | /"(?:""|[^"])*"/

// Identifiers - alphanumeric with special chars, or backtick-quoted
// Matches: Class, py:Class, oo:Method, name, inFile, etc.
ID: /[#$%&*\/:@A-Za-z\\^_|~][0-9.#$%&*\/:?@A-Za-z\\^_|~]*/ | /`(?:``|[^`])*`/

// ========================================
// WHITESPACE AND COMMENTS
// ========================================

COMMENT: /#[^\n]*/

%ignore /\s+/
%ignore COMMENT
