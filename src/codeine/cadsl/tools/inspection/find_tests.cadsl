# find_tests - Find test classes/functions for a module, class, or function
#
# Returns test coverage information for the specified target.
# Uses LEVENSHTEIN in post-processing to find tests that might be related
# to specific classes/functions even if naming conventions differ slightly.

query find_tests() {
    """Find test classes/functions for a module, class, or function."""

    param target: str = "";
    param module: str = "";
    param max_name_distance: int = 5;

    # Get all tests
    reql {
        SELECT ?t ?test_name ?file ?line
        WHERE {
            ?t type oo:Function .
            ?t name ?test_name .
            ?t inFile ?file .
            ?t atLine ?line .
            FILTER(REGEX(?test_name, "^test_|^Test|_test$"))
        }
        ORDER BY ?file ?line
        LIMIT 1000
    }
    | select { test_name, file, line, qualified_name: t }
    | python {
        # Match tests to classes using Levenshtein distance
        max_dist = ctx.params.get('max_name_distance', 5)
        target = ctx.params.get('target', '')

        def levenshtein(s1, s2):
            if len(s1) < len(s2):
                return levenshtein(s2, s1)
            if len(s2) == 0:
                return len(s1)
            prev = range(len(s2) + 1)
            for i, c1 in enumerate(s1):
                curr = [i + 1]
                for j, c2 in enumerate(s2):
                    curr.append(min(prev[j+1]+1, curr[j]+1, prev[j]+(c1!=c2)))
                prev = curr
            return prev[-1]

        def extract_class_from_test(test_name):
            # Extract probable class name from test name
            name = test_name
            for prefix in ['test_', 'Test']:
                if name.startswith(prefix):
                    name = name[len(prefix):]
                    break
            for suffix in ['_test', 'Test']:
                if name.endswith(suffix):
                    name = name[:-len(suffix)]
                    break
            return name

        # Convert rows to list of dicts if needed
        if hasattr(rows, 'to_pylist'):
            rows = rows.to_pylist()
        elif hasattr(rows, 'to_pydict'):
            d = rows.to_pydict()
            rows = [dict(zip(d.keys(), vals)) for vals in zip(*d.values())]

        tests_found = []
        for row in rows:
            if isinstance(row, dict):
                test_name = row.get('test_name', '')
            else:
                test_name = str(row) if row else ''
            probable_class = extract_class_from_test(test_name)
            entry = {
                'test_name': test_name,
                'file': row.get('file', '') if isinstance(row, dict) else '',
                'line': row.get('line', 0) if isinstance(row, dict) else 0,
                'qualified_name': row.get('qualified_name', '') if isinstance(row, dict) else '',
                'probable_target': probable_class
            }
            # If target specified, filter by Levenshtein distance
            if target:
                dist = levenshtein(probable_class.lower(), target.lower())
                if dist <= max_dist:
                    entry['match_distance'] = dist
                    tests_found.append(entry)
            else:
                tests_found.append(entry)

        result = tests_found
    }
    | emit { tests_found }
}
