# call_graph - Generate call graph from entry point
#
# Visualizes function/method call relationships as a Mermaid flowchart.
# Uses native graph_traverse and render_mermaid for pure declarative implementation.
# Set include_maybe=true to include probabilistic calls (duck-typed code).
#
# NOTE: Uses concept instead of type to support all languages (Python, C++, C#, JS)

diagram call_graph() {
    """Generate call graph from entry point."""

    param target: str required;
    param max_depth: int = 10;
    param format: str = "mermaid";
    param include_maybe: bool = false;

    reql {
        SELECT ?caller ?callee ?caller_name ?callee_name ?file ?line ?call_type ?caller_type ?callee_type
        WHERE {
            {
                ?caller calls ?callee .
                BIND("static" AS ?call_type)
            }
            UNION
            {
                ?caller maybeCalls ?callee .
                BIND("maybe" AS ?call_type)
            }
            ?caller name ?caller_name .
            ?caller inFile ?file .
            ?caller atLine ?line .
            ?caller concept ?caller_type .
            ?callee name ?callee_name .
            ?callee concept ?callee_type .
            FILTER(CONTAINS(?caller_type, "Method") || CONTAINS(?caller_type, "Function"))
            FILTER(CONTAINS(?callee_type, "Method") || CONTAINS(?callee_type, "Function"))
            FILTER(!CONTAINS(?caller_name, "::"))
            FILTER(!CONTAINS(?callee_name, "::"))
        }
        ORDER BY ?caller_name
    }
    | select { from_node: caller, to_node: callee, caller_name, callee_name, file, line, call_type }
    | when { {include_maybe} == false } filter { call_type == "static" }
    | graph_traverse {
        from: from_node,
        to: to_node,
        algorithm: bfs,
        max_depth: {max_depth},
        root: {target}
    }
    | render_mermaid {
        type: flowchart,
        edges: from_node -> to_node,
        direction: TD
    }
    | emit { diagram }
}
